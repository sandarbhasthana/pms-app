// // File: src/lib/__tests__/property-access.test.ts
// import { describe, it, expect, beforeEach, jest } from '@jest/globals';
// import { PropertyRole } from '@prisma/client';
// import {
//   hasRolePermission,
//   getRolesWithPermission,
//   validateRoleHierarchy,
//   hasPropertyAccess,
//   getUserPropertyRole
// } from '../property-context';

// // Mock Prisma
// jest.mock('../prisma', () => ({
//   prisma: {
//     userOrg: {
//       findFirst: jest.fn()
//     },
//     userProperty: {
//       findFirst: jest.fn()
//     }
//   }
// }));

// // Mock next-auth
// jest.mock('next-auth/next', () => ({
//   getServerSession: jest.fn()
// }));

// describe('Property Access Control', () => {
//   beforeEach(() => {
//     jest.clearAllMocks();
//   });

//   describe('Role Hierarchy Functions', () => {
//     describe('hasRolePermission', () => {
//       it('should return true when user role has sufficient permissions', () => {
//         expect(hasRolePermission(PropertyRole.PROPERTY_MGR, PropertyRole.FRONT_DESK)).toBe(true);
//         expect(hasRolePermission(PropertyRole.FRONT_DESK, PropertyRole.HOUSEKEEPING)).toBe(true);
//         expect(hasRolePermission(PropertyRole.MAINTENANCE, PropertyRole.GUEST_SERVICES)).toBe(true);
//       });

//       it('should return false when user role has insufficient permissions', () => {
//         expect(hasRolePermission(PropertyRole.GUEST_SERVICES, PropertyRole.PROPERTY_MGR)).toBe(false);
//         expect(hasRolePermission(PropertyRole.HOUSEKEEPING, PropertyRole.FRONT_DESK)).toBe(false);
//         expect(hasRolePermission(PropertyRole.SECURITY, PropertyRole.MAINTENANCE)).toBe(false);
//       });

//       it('should return true when roles are equal', () => {
//         expect(hasRolePermission(PropertyRole.FRONT_DESK, PropertyRole.FRONT_DESK)).toBe(true);
//         expect(hasRolePermission(PropertyRole.PROPERTY_MGR, PropertyRole.PROPERTY_MGR)).toBe(true);
//       });
//     });

//     describe('getRolesWithPermission', () => {
//       it('should return all roles with sufficient permissions', () => {
//         const roles = getRolesWithPermission(PropertyRole.HOUSEKEEPING);
//         expect(roles).toContain(PropertyRole.PROPERTY_MGR);
//         expect(roles).toContain(PropertyRole.FRONT_DESK);
//         expect(roles).toContain(PropertyRole.HOUSEKEEPING);
//         expect(roles).not.toContain(PropertyRole.MAINTENANCE);
//         expect(roles).not.toContain(PropertyRole.SECURITY);
//         expect(roles).not.toContain(PropertyRole.GUEST_SERVICES);
//       });

//       it('should return only PROPERTY_MGR for highest permission level', () => {
//         const roles = getRolesWithPermission(PropertyRole.PROPERTY_MGR);
//         expect(roles).toEqual([PropertyRole.PROPERTY_MGR]);
//       });

//       it('should return all roles for lowest permission level', () => {
//         const roles = getRolesWithPermission(PropertyRole.GUEST_SERVICES);
//         expect(roles).toHaveLength(6);
//         expect(roles).toContain(PropertyRole.PROPERTY_MGR);
//         expect(roles).toContain(PropertyRole.GUEST_SERVICES);
//       });
//     });

//     describe('validateRoleHierarchy', () => {
//       it('should return valid for sufficient permissions', () => {
//         const result = validateRoleHierarchy(PropertyRole.PROPERTY_MGR, PropertyRole.FRONT_DESK);
//         expect(result.valid).toBe(true);
//         expect(result.message).toBeUndefined();
//       });

//       it('should return invalid for insufficient permissions', () => {
//         const result = validateRoleHierarchy(PropertyRole.GUEST_SERVICES, PropertyRole.PROPERTY_MGR);
//         expect(result.valid).toBe(false);
//         expect(result.message).toContain('Insufficient permissions');
//         expect(result.message).toContain('PROPERTY_MGR');
//         expect(result.message).toContain('GUEST_SERVICES');
//       });

//       it('should handle invalid roles', () => {
//         const result = validateRoleHierarchy(null as any, PropertyRole.FRONT_DESK);
//         expect(result.valid).toBe(false);
//         expect(result.message).toBe('Invalid role provided');
//       });
//     });
//   });

//   describe('Property Access Functions', () => {
//     const mockPrisma = require('../prisma').prisma;

//     describe('hasPropertyAccess', () => {
//       it('should return true for organization-level access', async () => {
//         mockPrisma.userOrg.findFirst.mockResolvedValue({
//           userId: 'user1',
//           role: 'ORG_ADMIN',
//           organizationId: 'org1'
//         });

//         const result = await hasPropertyAccess('user1', 'property1', PropertyRole.FRONT_DESK);
//         expect(result).toBe(true);
//       });

//       it('should return true for property-level access with sufficient role', async () => {
//         mockPrisma.userOrg.findFirst.mockResolvedValue(null);
//         mockPrisma.userProperty.findFirst.mockResolvedValue({
//           userId: 'user1',
//           propertyId: 'property1',
//           role: PropertyRole.PROPERTY_MGR
//         });

//         const result = await hasPropertyAccess('user1', 'property1', PropertyRole.FRONT_DESK);
//         expect(result).toBe(true);
//       });

//       it('should return false for property-level access with insufficient role', async () => {
//         mockPrisma.userOrg.findFirst.mockResolvedValue(null);
//         mockPrisma.userProperty.findFirst.mockResolvedValue({
//           userId: 'user1',
//           propertyId: 'property1',
//           role: PropertyRole.GUEST_SERVICES
//         });

//         const result = await hasPropertyAccess('user1', 'property1', PropertyRole.PROPERTY_MGR);
//         expect(result).toBe(false);
//       });

//       it('should return false for no access', async () => {
//         mockPrisma.userOrg.findFirst.mockResolvedValue(null);
//         mockPrisma.userProperty.findFirst.mockResolvedValue(null);

//         const result = await hasPropertyAccess('user1', 'property1');
//         expect(result).toBe(false);
//       });

//       it('should handle database errors gracefully', async () => {
//         mockPrisma.userOrg.findFirst.mockRejectedValue(new Error('Database error'));

//         const result = await hasPropertyAccess('user1', 'property1');
//         expect(result).toBe(false);
//       });
//     });

//     describe('getUserPropertyRole', () => {
//       it('should return organization role for org-level access', async () => {
//         mockPrisma.userOrg.findFirst.mockResolvedValue({
//           userId: 'user1',
//           role: 'ORG_ADMIN',
//           organizationId: 'org1'
//         });

//         const result = await getUserPropertyRole('user1', 'property1');
//         expect(result.role).toBe('ORG_ADMIN');
//         expect(result.accessType).toBe('organization');
//       });

//       it('should return property role for property-level access', async () => {
//         mockPrisma.userOrg.findFirst.mockResolvedValue(null);
//         mockPrisma.userProperty.findFirst.mockResolvedValue({
//           userId: 'user1',
//           propertyId: 'property1',
//           role: PropertyRole.FRONT_DESK
//         });

//         const result = await getUserPropertyRole('user1', 'property1');
//         expect(result.role).toBe(PropertyRole.FRONT_DESK);
//         expect(result.accessType).toBe('property');
//       });

//       it('should return null for no access', async () => {
//         mockPrisma.userOrg.findFirst.mockResolvedValue(null);
//         mockPrisma.userProperty.findFirst.mockResolvedValue(null);

//         const result = await getUserPropertyRole('user1', 'property1');
//         expect(result.role).toBe(null);
//         expect(result.accessType).toBe(null);
//       });
//     });
//   });
// });
