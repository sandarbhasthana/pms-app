/**
 * PDF Report Generator
 *
 * Generates PDF reports using PDFKit (same as existing invoice generation)
 */

import PDFDocument from "pdfkit";
import path from "path";
import { ReportData } from "../types";

export async function generatePDF(data: ReportData): Promise<Buffer> {
  try {
    // Use custom font to avoid .afm file issues (same as existing implementation)
    const fontPath = path.join(
      process.cwd(),
      "public/fonts/FiraSans-Regular.ttf"
    );

    // Create document with custom font
    const doc = new PDFDocument({
      size: "A4",
      margin: 50,
      bufferPages: true,
      autoFirstPage: false,
      font: fontPath
    });

    // Add the first page
    doc.addPage();

    const buffers: Buffer[] = [];
    doc.on("data", (chunk) => buffers.push(chunk));
    const pdfReady = new Promise<Buffer>((resolve) => {
      doc.on("end", () => resolve(Buffer.concat(buffers)));
    });

    // Header - Title
    doc.fontSize(20).text(data.title, { align: "center" });
    doc.moveDown(0.5);

    // Subtitle if exists
    if (data.subtitle) {
      doc.fontSize(12).text(data.subtitle, { align: "center" });
      doc.moveDown(0.5);
    }

    // Metadata
    doc.fontSize(10);
    doc.text(`Organization: ${data.organizationName}`);

    if (data.propertyName) {
      doc.text(`Property: ${data.propertyName}`);
    }

    if (data.dateRange) {
      doc.text(
        `Date Range: ${data.dateRange.start.toLocaleDateString()} - ${data.dateRange.end.toLocaleDateString()}`
      );
    }

    doc.text(
      `Generated: ${data.generatedAt.toLocaleString()} by ${data.generatedBy}`
    );
    doc.moveDown(1);

    // Summary section if exists
    if (data.summary && Object.keys(data.summary).length > 0) {
      doc.fontSize(14).text("Summary", { underline: true });
      doc.moveDown(0.5);
      doc.fontSize(10);

      Object.entries(data.summary).forEach(([key, value]) => {
        // Skip emptyMessage in summary section (will be shown separately)
        if (key === "emptyMessage") return;

        const label = key.replace(/([A-Z])/g, " $1").trim();
        const displayLabel = label.charAt(0).toUpperCase() + label.slice(1);
        doc.text(`${displayLabel}: ${value}`);
      });

      doc.moveDown(1);
    }

    // Check for empty message
    const emptyMessage = data.summary?.emptyMessage;
    if (emptyMessage && typeof emptyMessage === "string") {
      doc
        .fontSize(12)
        .fillColor("#f59e0b")
        .text(emptyMessage, { align: "center" });
      doc.moveDown(1);
      doc.fillColor("#000000");
    }

    // Data table
    if (data.data && data.data.length > 0) {
      doc.fontSize(14).text("Details", { underline: true });
      doc.moveDown(0.5);
      doc.fontSize(9);

      // Create simple table
      const headers = Object.keys(data.data[0]).map((key) =>
        key.replace(/([A-Z])/g, " $1").trim()
      );

      // Table header
      const startX = 50;
      let startY = doc.y;
      const colWidth = (doc.page.width - 100) / headers.length;
      const rowHeight = 20;

      // Draw header row
      doc
        .rect(startX, startY, doc.page.width - 100, rowHeight)
        .fillAndStroke("#7210a2", "#7210a2");

      doc.fillColor("#ffffff");
      headers.forEach((header, i) => {
        doc.text(header, startX + i * colWidth + 5, startY + 5, {
          width: colWidth - 10,
          align: "left"
        });
      });

      startY += rowHeight;
      doc.fillColor("#000000");

      // Draw data rows
      data.data.forEach((row, rowIndex) => {
        if (startY > doc.page.height - 100) {
          doc.addPage();
          startY = 50;
        }

        // Alternate row colors
        if (rowIndex % 2 === 0) {
          doc
            .rect(startX, startY, doc.page.width - 100, rowHeight)
            .fillAndStroke("#f3f4f6", "#d1d5db");
        } else {
          doc
            .rect(startX, startY, doc.page.width - 100, rowHeight)
            .stroke("#d1d5db");
        }

        doc.fillColor("#000000");
        Object.values(row).forEach((value, i) => {
          doc.text(String(value ?? ""), startX + i * colWidth + 5, startY + 5, {
            width: colWidth - 10,
            align: "left"
          });
        });

        startY += rowHeight;
      });
    }

    // Footer
    doc
      .fontSize(8)
      .fillColor("#6b7280")
      .text(
        "This is an automated report generated by the Property Management System.",
        50,
        doc.page.height - 50,
        { align: "center" }
      );

    doc.end();
    const pdfBuffer = await pdfReady;
    return pdfBuffer;
  } catch (error) {
    console.error("Error generating PDF:", error);
    throw new Error("Failed to generate PDF report");
  }
}
